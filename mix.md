# 随写随记
> 摘自
> https://juejin.cn/post/6956360277185003556
> 

### 1. 箭头函数和普通函数的区别

a. 箭头函数和普通函数样式不同，箭头函数声明简洁清晰，通过 `=>`声明，普通函数是用`function`声明。

b. 箭头函数声明时候会捕获所在的上下文的this值，作为自己的this值，定义时候确定并固定。

c. 箭头函数不能作为构造函数使用，因此不能通过`new`关键字来创建对象，（因为箭头函数没有自己的this，它的this其实是继承了外层执行环境中
this，且this值指向不会改变，作为构造函数的this是指向创建的新对象的）

d. 箭头函数没有自己的arguments。在箭头函数中访问arguments实际上获得的是外部局部执行环境中的值。

f. 箭头函数没有原型prototype

g. 箭头函数不能作为Generator函数，不能使用yield关键字。

### 2. var,let,const 之间的区别

从以下三方面进行分析，

`变量提升方面：` var声明的变量存在变量提升，记变量可以在声明之前调用，值为`undefined`。
let 和 const 不存变量提升问题（其实是有提升过程的，只是let和const具有一个暂时性的死区的的概念，即没有声明之前不能使用，否则报错）


`块级作用域方面：` var 不存在块级作用域，let 和 const存在块级作用域。

`声明方面` var允许重复声明变量 let 和 const 在同一作用域下不允许重复声明变量。其中const声明一个只读的常量，一旦声明常量的值不能改变、。

**如何使const声明的对象内属性不可变，只可读**
如果const声明一个对象，对象内的属性是可以改变的。
```js
    const obj = { name : "名字"};
    obj.name = "新名字";
    console.log(obj.name); // 新名字 
```

因为const声明的obj只是保存了其对象的引用地址。只要地址不变就不会报错。

使用`Object.freeze(obj)`冻结obj，就能是其内部的属性不可变，但是obj对象是有属性的对象，该对象的属性还是能够改变的，如果想要全部不可变，需要
递归逐层冻结。

### 3.Bigint和Number的区别

Number类型的数字`有精度限制，`数值的精度只能到53个二进制位，相当于16个十进制位，大于这个范围的证书，就无法精准表示了。

Biginit没有位数的限制，任何位数的证书度可以精确表示，但是其值能用于表示整数，且为了与Number进行区分，bigint类型的数据
必须添加后缀n bingint可以使用负号(-)，但是不能使用正号(+)

Number类型数字不能和Biginit类型的数字进行混合计算。

### 4. 基本数据类型和引用数据类型的区别

**基本数据类型**

a. 基本数据类型的值是不可变得，之而立你就可以联想到，是不是所有关于字符串和数字的方法都是有返回值的，而不是改变源字符串或数字。
例如：
```js
    let a = 'abc';
    a.split('');
    console.log(a); //abc
```

b. 基本数据类型不可以添加属性和方法，虽然不会报错，但也只是因瞬间转为相应包装对象，操作完又转化会基本数据类型，不会保存结果。

c. 基本数据类型的赋值是简单赋值，基本数据类型的比较是值得比较。

d. 基本数据类型存档在内存的栈区。

**引用数据类型**

a. 引用类型的值是可以改变的，例如对象就可以用过修改对象属性值更改对象。

b. 引用类型可以添加属性和方法。

c. 引用类型的赋值是对象引用，即声明的变量标识符，存储的只是对象的指针地址。

d. 引用类型的比较是引用（指针地址）的比较。

e. 引用类型是勇士保存在堆区和栈区的，栈区保存变量的标识和指向堆内存的地址。


### 5. defer和async的区别

大家应该都知道在script中标签内有这两个属性defer和async，

`defer`中文的意思是延迟。用途是表示脚本会被延迟到整个页面都解析完毕后再运行，因此在`<script>`元素中设置defer属性相当于
告诉浏览器立即下载，但延迟执行。

HTML5规范要求脚本按照它们出现的先后顺序执行，因此第一个延迟的脚本会先于第二个延迟脚本执行，但执行脚本之间，存在依赖，需要执行
的先后顺序时，就可以使用defer延迟执行，我觉得吧script脚本放在body底部和defer差不多。

`async`中文意思是异步，这个属性与defer相似，都用于改变处理脚本的行为，同样与defer类似，async 只适用于外部脚本文件，
并告诉浏览器立即下载文件，但与defer不同的是，标记为async的脚本并不保证按照它们的先后顺序执行。

指定aysnc的目的是不让页面等待两个脚本下载和执行，从而`异步加载页面`其他内容，这使用与之间的`互不依赖`的脚本。


### 6.async await 对比Promise的优缺点

`async await的优点`

a. 它做到了真正的串行的同步写法，代码阅读相对容易。

b. 对其他条件语句和其他流程语句比较友好 可以直接卸载判断条件里面。

```js
    function a (){
        return new Promise((resolve,reject)=>{
            setTimeout(()=>{
                resolve('a')
            }, 2000)
        })
    }

    async function f() {
        try{
            if ( await a() === 'a') {
                    console.log('yes, it is!') // 会打印
            }
        }catch (e){

        }
    }    
```
c. 处理复杂流程时，在代码清晰度上面有有优势

`async/await缺点`

a. 无法处理Promise返回的reject对象  要借助 try catch

b. 用await可能会导致性能问题，因为await会阻塞代码，也许之后的同步代码并不依赖于前者，但是仍然需要等待前者完成，导致代码失去了并发性。

c. try...catch... 内部变量无法传递给下一个try...catch.... Primise的then/catch内部定义的变量，能够通过then的链条的参数传递给下一个
then/catch 但是async await的try内部变量 如果用let catch则无法传递给下一个try catch，只能用外层作用域先定义变量

`但async/await确确实实是解决了promise一些问题的。更加灵活的处理异步`

`promise的一些问题`

a. 一旦执行，无法中途取消，链式调用多个then中间不能随便跳出来。

b. 错误无法在外部捕捉到，只能通过内部进行预判处理，如果不设置回调函数，Promise内部抛出错误，不会反应到外部

c. Promise内部如何执行，检测起来很困难，当处于pending状态时，无法得知目前进展到哪个阶段。

### 7. GET和POST的区别

a. GET是将参数写在URL的`?`的后面，并用&分隔不同参数。而POST是将信息存放在Message Body中
传送。参数不会显示在URL中（Restful规范中是这样的，但POST在有需要的时可以把参数放在URL中，）
GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值
也就是GET通过地址传值，POST通过表单传值。

b. GET请求提交数据有长度限制，`HTTP 协议本身没有限制 URL 及正文长度`对URL的限制  大多是服务器和浏览器的原因，
POST请求没有内容长度的限制。

c. GET请求返回的数据内容会被浏览器缓存起来，而每次提交的POST请求，浏览器不会缓存POST请求返回的内容。

d GET对数据进行查询，POST主要对数据进行正删改，简单来说，GET只读，POST是写。

e 关于安全性，GET请求方式从浏览器的URL地址可以看到参数，所以POST更安全，其实无论GET还是POST都是不安全的，因为
http协议是明文传输，只要拦截到封包就能轻易获取重要资讯，想要安全传输资料，必须使用SSL/TLS来对封包进行加密。也就是HTTPS

`那为什么推崇使用post来处理敏感数据呢？`

因为get请求记录会保存在浏览器上，上网日志中，而使用post，因为数据不会记录在浏览器的记录中和网址访问记录中，这样会有更大的安全性。

f. `一个误区` 说get产生一个TCP数据包，post产生两个TCP数据包

`其说法`：对GET方式的请求，浏览器会把http header和data一并发送出去，服务端响应200，请求成功。

对于POST请求，浏览器会先把http header先发送给服务器，告诉服务器等一下会有数据过来，服务端响应100 continue，告诉服务器已经准备好接受数据，
，浏览器在post发送一个data给服务端，服务器响应200，请求成功

`为其正名`上面所说的post会比get多发送一个TCP包其实是不够严谨的，多发的那个`expect 100 continue header`报文，是由客户端对post的请求策略决定的。
主要是避免资源浪费，如`带宽，数据传输消耗的时间等等，`所以客户端会发送header来探路，如果失败了就不发送data,从而减少资源浪费，所以是否再发送一个包取决于
客户端的实现策略，和get/post没什么关系，有的客户端如FireFox就只发送一个包。

