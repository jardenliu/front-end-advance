
# 浏览器渲染过程及原理


### 五大主流浏览器和四大内核
1. IE浏览器：Trident
2. Chrome浏览器：以前是Webkit，现在是Blink；
3. Firefox浏览器：Gecko
4. Safari浏览器：Webkit；
5. Opera浏览器：Presto（自己的），后来是Webkit，现在是Blink； 

### 浏览器的主要构成
1. 用户界面 － 包括地址栏、后退/前进按钮、书签目录等，UI界面。
2. 浏览器引擎 － 用来查询及操作渲染引擎的接口。
3. 渲染引擎 － 用来显示请求的内容，例如，如果请求内容为html，它负责解析html及css，并将解析后的结果显示出来。
4. 网络 － 用来完成网络调用，例如http请求，它具有平台无关的接口，可以在不同平台上工作。
5. UI后端 － 用来绘制类似组合选择框及对话框等基本组件，具有不特定于某个平台的通用接口，底层使用操作系统的用户接口。
6. js解释器 － 用来解释执行JS代码。
7. 数据存储 － 属于持久层，浏览器需要在硬盘中保存类似cookie的各种数据，Html5定义了web database技术，这是一种轻量级完整的客户端存储技术

![浏览器构成](https://pic002.cnblogs.com/images/2011/265173/2011110316262567.png)


## 渲染
> 渲染引擎的职责就是渲染，即在浏览器窗口中显示所请求的内容。默认情况下，渲染引擎可以显示html、xml文档及图片，它也可以借助插件（一种浏览器扩展）显示其他类型数据，例如使用PDF阅读器插件，可以显示PDF格式

#### 从简单的开始
简单的俩说，页面渲染就是浏览器将html代码根据CSS定义的规则显示在浏览器窗口中的这个过程。
1. 浏览器从用户输入的地址开始，向服务器发出请求，服务器返回html文件。
2. 浏览器开始载入html文件，发现<head>标签内有一个<link>标签引用外部CSS文件；
3. 浏览器又发出CSS文件的请求，服务器返回CSS文件。（同步）
4. 浏览器继续载入html中<body>部分的代码，并且CSS文件已经拿到手了，可以开始渲染页面
5. 浏览器在代码中发现一个<img>标签引用了一张图片，向服务器发出请求（异步）。此时浏览器不会等到图片下载完，而是继续渲染后面的代码
6. 服务器返回图片文件，由于图片占用了一定面积，影响了后面段落的排布，因此浏览器需要回过头来重新渲染这部分代码
7. 浏览器发现了一个包含一行JavaScript代码的<script>标签，赶快运行它
8. javascript脚本执行了这条语句，它命令浏览器隐藏掉代码中的某个<div> （style.display=”none”）。杯具啊，突然就少了这么一个元素，浏览器不得不重新渲染这部分代码。
9. 终于等到了</html>的到来，浏览器泪流满面……
10. 用户美滋滋点了一下界面中的“换肤”按钮，Javascript让浏览器换了一下<link>标签的CSS路径
11. 浏览器(心态爆炸💥)向服务器请求了新的CSS文件，重新渲染页面

--->>> 例1
 
#### HTML渲染主流程
基本流程: `dom树` -> `构建render树` -> `布局render树` -> `绘制render树`
![渲染流程](https://pic002.cnblogs.com/images/2011/265173/2011110316263715.png)

渲染引擎开始解析html，并将标签转化为内容树中的dom节点。接着，它解析外部CSS文件及style标签中的样式信息。这些样式信息以及html中的可见性指令将被用来构建另一棵树——render树。

Render树由一些包含有颜色和大小等属性的矩形组成，它们将被按照正确的顺序显示到屏幕上。

Render树构建好了之后，将会执行布局过程，它将确定每个节点在屏幕上的确切坐标。再下一步就是绘制，即遍历render树，并使用UI后端层绘制每个节点。

* webkit

![渲染流程](https://pic002.cnblogs.com/images/2011/265173/2011110316264892.png)

* Geoko

![渲染流程](https://pic002.cnblogs.com/images/2011/265173/2011110316270146.jpg)

* Geoko中的Frame树与webkit的Render树，Geoko的Reflow和Webkit的Layout，理念上来说是一样的。
* Geoko在解析HTMl和构建DOM树之间有一层Content Sink（内容接收器），用于生成DOM元素，这是webkit所没有的

### 解析与DOM树构建

#### 解析
解析的两个子过程——**语法分析**及**词法分析**

- **词法分析** ：将输入分解为符号
   - **符号**：是语言的词汇表——基本有效单元的集合。
   - **词法分析器** ：将输入分解为合法的符号
- **语法分析**：指对语言应用语法规则。
   - **解析器**：根据语言的语法规则分析文档结构，从而构建解析树
   
![解析](https://pic002.cnblogs.com/images/2011/265173/2011110316272491.png)

* 解析的过程进一步可视为四步：源文档 -> 词法分析 -> 语法分析 -> 解析树
* 解析的更细致的迭代过程是：
   1. 词法分析器得到符号，传给解析器
   2. 解析器用符号匹配语法规则
   ```txt
    * 若匹配上规则，则符号对应的节点将被添加到解析树上
    * 若没有匹配上规则，解析器将在内部保存该符号，然后从词法分析器取下一个符号，再次匹配规则
     * 若在之后能使内部符号匹配上规则，则符号对应的节点将被添加到解析树上
     * 若到最后都没有匹配上规则，解析器将抛出一个异常，这意味着文档无效或是包含语法错误。
   ```
   3. 最终得到解析树或异常
  
![转换](https://pic002.cnblogs.com/images/2011/265173/2011110316274796.png)
* 解析一般在转换（将输入文档转换为另一种格式）中使用，因此，解析树可能不是最终结果，比如编译。其过程为：***源码 -> 解析 -> 解析树 -> 转换 -> 机器码***

例:

```html
<html>
<body>
<p>
Hello DOM
</p>
<div><img src=”example.png” /></div>
</body>
</html>

```
![dom](https://pic002.cnblogs.com/images/2011/265173/2011110316280265.png)


